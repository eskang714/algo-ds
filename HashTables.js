/*
Hash Tables are a data structure that allows one to organize data. 
The usecases are numerous. For example a library can keep track of how many 
books they would have for a specific title. 

Hash Tables store information with a key. Kind of like a 
two dimensional array in the most simplest forum. 

~Logic Cooking Recipe Notes
Fundamentally Hash Tables are structured as
1. Take a value and create a key associated with it. 
2. Use the key as an index for an array/map for look up and store the value. 


// Basic concepts alogrithm into function
// lets say we want to organize the data into evens and odds
  inputs [1,2,3,4,5,6,7,8]
// Array
  inputs [1,2,3,4,5,6,7,8]

  var hashTable = new Array(2) // creating an array with a length of 2
  hashTable[0] = new Array // creating a new array to store evens 
  hashTable[1] = new Array // creating a new array to store odds

  for (let i = 0; i < inputs.length; i++) {
    // we are using the remainder operator to determine if the value is even or odd
    // then the value becomes the key to the hashTable
    var key = inputs[i] % 2 // output will be either 0 or 1
    
    // with the key we will push the value into the array of the hash table
    hashTable[key].push(inputs[i])
  }
  // we will return a 2D array with the values sorted as evens or odds
  return hashTable
  
  // Table
    inputs [1,2,3,4,5,6,7,8]
    var hashTable = new Map() // creating our map

    hashTable.set('0', []).set('1', []) // adding arrays to keys 0 and 1

    for (let i = 0; i < inputs.length; i++) {
    // we are using the remainder operator to determine if the value is even or odd
    // then the value becomes the key to the hashTable
    var key = inputs[i] % 2 // output will be either 0 or 1
    
    // with the key we will push the value into the array of the hash table
    hashTable[key].push(inputs[i])
    }
*/

const validAnagram242 = () => {
  /*
    Problem: leetcode 242: Valid Anagram
    https://leetcode.com/problems/valid-anagram/

    Solution explained: 
    We are given two strings, they just have to have the same characters and 
    the same number of occurances of the character. We just have to map the characters
    and the occurences to the characters for each string. If the hash tables do
    end up being the same we can then add them in. 

    ~Logic Cooking Recipe Notes
    1. Create a function that will map the strings into a hashTable
      a. The function will handle one input string
      b. It will create an array with the length of 26 to 
          represent each character of the alphabet
        -Assign each element of the array as 0
      c. Loop through each character of the string and the key will be the 
          "character code - 97". (lowercase 'a' is 97 in ASCII, 0 will be the start). 
        -For each loop, we will increment the value by 1 when we hash the table
      d. return the map but parse it as a string. 

    2. Run the function with the values given
      i.e. functionStepOne(string1); functionStepOne(string1)
    3. If we compare the results from running the functions and they are equal to each other, 
      return true, otherise return false
  */
  /**
   * @param {string} s
   * @param {string} t
   * @return {boolean}
   */
  var isAnagram = function(s, t) {
    const mapper = (str) => {
        let mapping = new Array(26).fill(0)
        for (let char of str) mapping[char.charCodeAt()-97]++
        return mapping.toString()
    }
    return mapper(s) == mapper(t)
  }
}


const twoSum1 = () => {
  /*
    Problem: leetcode 1: Two Sum
    https://leetcode.com/problems/two-sum/

    Solution explained: 
    We are given two inputs, an array and an integer. 
    The array contains unique integers only. Within the array there 
    are two summands that will create a sum value of the input integer. 
    We are tasked to find the indexs of the two summand elements of the array 
    and return them. 

    ~Logic Cooking Recipe Notes
    1. We are going to create a hashmap with the map function in javascript.
      -properties of the hashmap:
        1. The keys will be genertated as an integer generated by 
          target sum intger - element of array that we are looping through.
        2. The value will be the index of an element that is a summand 
          of an array element value that is the other summand for the target sum integer.

    2. We will loop through the array with a logic gate.
      1. We will loop through the array for each element
      2. If the element is a key in the hashmap, 
      return the index of the element and the key value of the 
      hashmap (this should be the index of the desired summand element).
      3. Else, we will create a new entry for the element we are looping through. 
      The key for the entry will be the "target sum integer - element integer".
      4. Loop again until we have visited all elements of the array. 
  */
  /**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
  var twoSum = function(nums, target) {
    var hashmap = new Map()

    for (let index in nums) {
      let element = nums[index]

      if (hashmap.has(element)) {
          return [index, hashmap.get(element)]
      } else {
          let key = target - element
          hashmap.set(key, index)
      }
    }
  }

  // Optimized code:
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number[]}
   */
  var twoSumOptimized = function(nums, target) {
    /*
      We are creating a variable with the property of on object. 
      If you think about it, it is a shorthand way of creating a "hashmap". 
      Because we inside the curly braces, hashmap = {this.variable = variable} performs 
      similar to a map() but we do not have to call the map method nor use any methods 
      to assign values to keys within the object. This will save us some time. 

      When you want to add elements, it just assigns a new property with a value. 
      We can add as many as we want without explicity calling a method, however we still
      need to call a method for rememoving properties of an object. This will not be an 
      issue because we are only ingesting data from an array where all elements are unique. 
    */
    var hashmap = {}

    /*
      I declared the element variable outside of the loop, 
      this is done for memeory management and to reduce garbage inside the memory
      where the for loop has to deal with any declarations inside. 
      I wanted to reduce the look up times for the "hashmap" by having pointer
      where we can just find the value of the hashmap we need for the loop. 
    */
    var element

    /* for counter vs for in 
    // arrLength = 10000000
    var test = new Array(arrLength)
    console.time()
    for (let item in test) {
        item
    }
    console.timeEnd()
    console.time()
        for (let i = 0; i < test.length; i++) {
        test[i]
    }
    console.timeEnd()
    This is the only quantitive way I can check the loop speed. 
    The in method is better optimized for bigger data sizes 
    than the coutner loop. Choose your poison!
    */
    for (let index = 0; index < nums.length; index++) {
        /*
          With the element variable, we are saving the value of the look up
          so we do not have to waste cycles looking up the value of the array. 
          array look ups perform in an odd way. The data is for the array is 
          saved as one memory block. So lets say we have an array of 
          [1,2,3,4, n...]. Now from what I understand, 
          If we wanted to look up the index of n, we would access the 
          whole data "[1,2,3,4, n...]", then look up the search 
          by finding where the value of index n is at. The reason why I prefer 
          pointers styles of saving and try to utilize them as much as possible 
          is because each value is saved as their own "block" within the memory. 
          If we wanted to access them then it would just point to where the value is
          in o(1) look up. If we explicitly call what "data" we need, then 
          we can save time for accessing the data. 
        */
        element = nums[index]

        /* 
          JavaScript has a built in method of "in" where the arguments take 
          "property" in "object" and return a boolean result. The nice thing about 
          JavaScript is that it has falsy, Mozilla has a nice article about it 
          in their api doc which is linked here: 
          https://developer.mozilla.org/en-US/docs/Glossary/Falsy
          
          Leveraging falsy over the method reduces more time, where methods need 
          to be called to return a value. If we use a falsy, we can bypass it all
          and return faster results. 

          Also another note: assigning properties such as 
          'let key = 1'
          'hashmap.key = 1'
          This will litterally store the data with the 
          property value as 'key' instead of '1'. When you declare an property with the 
          object[~property/key~] = value way, it will store it as object.1 = 1. 

          The same can be said for look ups: 
          'let key = 1'
          console.log(hashmap.key) will return hashmap.key instead of hashmap.1
        */
        if (hashmap[element] != null) return [index, hashmap[element]]
        hashmap[target - element] = index
    }
  }
}